## Lab4 死锁

### 代码运行结果分析

关键字synchronized用来修饰一个方法或者是一个代码块，保证在同一时刻最多只有一个线程
能够执行这段代码。所以如果有一个线程访问了这个方法或者代码块的时候，其他线程此时再对他进行的访问将会被阻塞。

![deadlock](https://raw.githubusercontent.com/Scintillium/Res/master/DOL-RES/deadlock.PNG)

主函数的时间轴

可以看到在主函数中首先创建了一个线程，在线程开始之后，运行while语句，需要经过一定的时间开始调用
a.methodA(b)语句来打印文字。
而在另一方面，由于主函数是一个runnable的继承类，所以在运行的时候会在后台另外开始执行run中的语句。则调用b.methodB(a)。可以看到这两个方法，其中methodA的执行时间与count的值有关，而methodB的执行时间再线程执行开始的时候就开始运行，两者之间存在一定的时间差。
但是由于在执行代码的时候，我们让程序跑了100遍，这两个类的方法会互相调用，即a.methodA(b)调用b中的b.last()方法来打印信息，而b.methodB(a)则调用a.last()，如果这两者在同时执行的时候，其中一个占有A确请求B中的方法，另一个占有B确请求A中的方法，且其中的方法都被synchronized关键字修饰，只能同时执行一次，两者互相占有对方所需要的资源，但只有当前线程执行完才会释放，所以死锁就这样产生了。

结果如下

![screenshot](https://raw.githubusercontent.com/Scintillium/Res/master/DOL-RES/deadlock-screenshot.png)

### 死锁产生的四个必要条件

1. 互斥条件。即一个资源每次只能被一个进程所使用

2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放

3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺

4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

发生死锁必然满足这四个条件。
